# -*- coding: utf-8 -*-
"""
Created on Tue May 18 19:02:58 2021

@author: apizz
"""

"""Simple layer profile plots"""

import numpy as np
import nibabel as nb
import matplotlib.pyplot as plt
import os

STUDY_PATH = "D:\\Pilot_Exp_VASO\\pilotAOM"
SUBJ = ['sub-02','sub-03','sub-04']
CONDT = ['standard']    # ['standard', 'magn_only','magn_phase']
FUNC = ['BOLD', 'VASO']    # 'VASO'
NL = '9'
CL = '300'
thr_col = [0.5, 0.2]
mask = '0'

for si in SUBJ:
    for co in CONDT:
        for fu in FUNC:
            print(si + co +fu)
            PATH_ACT = os.path.join(STUDY_PATH, si, 'derivatives', 'func', 'AOM', 'vaso_analysis', co, 'ACTIVATION', 'scaled_4')
            PATH_SEG = os.path.join(STUDY_PATH, si, 'derivatives', 'func', 'AOM', 'vaso_analysis', 'segmentation_4')

            # Activation maps
            if mask=='1':
                FILE1_ACT = os.path.join(PATH_ACT, 'masked_scaled_4_act_allTask_' +fu + '.nii.gz')
            else:
                FILE1_ACT = os.path.join(PATH_ACT, 'scaled_4_act_allTask_' +fu + '.nii')
            #FILE1_ACT = os.path.join(PATH_ACT, 'scaled_4_act_allTask_' +fu + '.nii')

            # Metric file generated by LN2_LAYERS
            FILE2 = os.path.join(PATH_SEG, si + '_seg_rim_4_' + NL + '_metric_equidist.nii')
            FILE3 = os.path.join(PATH_SEG, si + '_seg_rim_4_' + NL + '_layers_equidist.nii')

            # Column or area definitions
            FILE4 = os.path.join(PATH_SEG, 'BOLD_masked_colums_mean.nii.gz')

            # =============================================================================
            # Load image data, you can think of this as an activation map.
            nii1 = nb.load(FILE1_ACT)
            data = nii1.get_fdata()
            # Load normalized depths
            nii2 = nb.load(FILE2)
            norm_depth = nii2.get_fdata()

            # Load layers (quantized normalized depths)
            nii3 = nb.load(FILE3)
            layers = nii3.get_fdata()
            idx_layers = np.unique(layers.astype("int"))
            idx_layers = idx_layers[1:]  # Remove layers with index 0
            nr_layers = idx_layers.size
            layer_bins = np.zeros(nr_layers + 1)  # +1 for zeros indices

            # Load columns
            nii4 = nb.load(FILE4)
            colums = nii4.get_fdata()
            idx_columns = np.unique(colums.astype("int"))
            idx_columns = idx_columns[1:]  # Remove columns with index 0
            nr_columns = idx_columns.size

            # Output matrix
            # layers_columns = np.zeros((nr_layers, nr_columns))


            # Prepare plot
            fig, (ax1, ax2) = plt.subplots(1, 2)
            fig.suptitle('Layer profiles in two alternative ways')

            for j in idx_columns:
                # Take voxels of a single column
                idx = colums == j
                data_roi = data[idx]
                norm_depth_roi = norm_depth[idx]
                layers_roi = layers[idx]

                # Before layer quantization
                ax1.scatter(norm_depth_roi, data_roi*100, alpha=0.1, marker=".")
                ax1.set_xlim((0, 1))
                # ax1.set_ylim((0, ))
                ax1.set_xlabel("Normalized cortical depth")
                ax1.set_ylabel("Percent signal change")

                # After layer quantization
                for i in idx_layers:  # Compute bin averages
                    layer_bins[i] = np.mean(data_roi[layers_roi == i])
                    # layers_columns[i-1, j-1] = layer_bins[i]*100
                ax2.plot(idx_layers, layer_bins[1:]*100, linewidth=1)
                # ax2.set_ylim((90, 120))
                ax2.set_xlabel("Layers (0=white matter)")
                ax2.set_ylabel("Percent signal change")

            plt.savefig(os.path.join(PATH_ACT,'mask_LayerProfile_C_' + CL + '_L_' + NL + '_mask_' + mask + '_' +fu), bbox_inches='tight')
            plt.show()

            print("Finished.")


            # layers_columns_sign = []
            # colums_bis = np.copy(colums)

            # #### Find significant colums
            # for j in range(0, len(idx_columns)):
            #     if fu == 'BOLD':
            #         tt = thr_col[0]
            #     else:
            #         tt = thr_col[1]

            #     y = sum(layers_columns[:,j] > tt)

            #     if y > 0:
            #         layers_columns_sign.append([j, y])
            #         print("Significant column with {} significant layers: {} " .format(y, j))
            #     else:
            #         idx = colums_bis == j
            #         colums_bis[idx] = 0
            # # Sorting
            # arr = np.array(layers_columns_sign)
            # sorted_columns = arr[arr[:, 1].argsort()[::-1]]

            # # Saving a new nifti file
            # columns_filtered = nb.Nifti1Image(colums_bis, affine=nii4.affine)
            # out_name = si + '_columns_filtered_mask_' + mask + 'C_' + CL + '_L_' + NL + '_' + fu + ".nii"
            # nb.save(columns_filtered, os.path.join(PATH_ACT, out_name))

            # # Plot

            # plt.title('Significant Layer Profile')
            # for i in sorted_columns[:,0]:
            #     plt.plot(idx_layers, layers_columns[:, i], linewidth=1, label='Col ' + str(i))
            #     plt.xlabel("Layers (0=white matter)")
            #     plt.ylabel("Percent signal change")
            # plt.legend(bbox_to_anchor=(1.04,1), loc="upper left")
            # plt.savefig(os.path.join(PATH_ACT, 'Significant_LayerProfile_C_' + str(len(sorted_columns)) + '_L_' + NL + '_mask_' + mask + '_' +fu), bbox_inches='tight')
            # plt.show
